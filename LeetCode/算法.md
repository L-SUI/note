# 算法总结

## 回溯剪枝
```
第一要素:
options条件选项展开出一棵解的空间树
第二：
条件约束restrains用于为这棵树剪枝，剪去不能产生正确解的节点，避免无效搜索。

第三个要素：目标（结束条件），明确目标知道何时去将解加入解集。

探索到某一步时，发现当前的部分解不能通向正确的完整解，搜下去没有意义。

此时回退一步，撤销当前的选择，回到上一个选择的状态，做别的选择。

此路不通，退回去，尝试别的路，是一个「choose, explore, unchoose」的过程。

套路做法
用 for 循环去枚举出所有的选择
做出一个选择
基于这个选择，继续往下选择（递归）
上面的递归结束了，撤销这个选择，进入 for 循环的下一次迭代
回溯 与 嵌套循环
回溯是一种算法，递归不是算法，是一种计算机解决问题的方式。

回溯是借助递归实现的。如果回溯不借助递归，它只能借助循环。

用 for 循环枚举出当前的选项，选了一个，选下一个，又要嵌套一层循环，枚举出可选的选项。

如果要选很多个，就导致多重的循环嵌套，很费力也很丑。

于是借助递归解决，因为递归和子递归就是层级嵌套的关系。

而且，树在结构上，具有高度的重复性，每一个节点，都是当前子树的根节点，调用递归函数负责当前子树的搜索。

虚拟的解空间树
回溯算法并没有显式地创建数据结构，也不是基于已有的数据结构做搜索。

它是隐式地，通过递归，构建出一棵解的空间树。这个空间树中包含了所有的解。

然后通过 dfs 的搜索方式，把解给全部找出来。
```